use super::*;
use frame_support::sp_runtime::Saturating;
use frame_support::{storage_alias, traits::OnRuntimeUpgrade};
use log;

pub mod v0 {
	use super::*;
	use codec::{Decode, Encode};
	use frame_support::pallet_prelude::*;

	#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo, Default)]
	#[scale_info(skip_type_params(DescriptionLimit, NameLimit, AccountLimit))]
	pub struct Proposal<
		DescriptionLimit: Get<u32>,
		NameLimit: Get<u32>,
		AccountId,
		AccountLimit: Get<u32>,
	> {
		pub proposer: AccountId,
		pub name: BoundedVec<u8, NameLimit>,
		pub description: BoundedVec<u8, DescriptionLimit>,
		pub historical: bool,
		pub status: bool,
		pub voter_accounts: BoundedVec<AccountId, AccountLimit>,
	}
	#[storage_alias]
	pub type Proposals<T: Config> = StorageDoubleMap<
		Pallet<T>,
		Blake2_128Concat,
		<T as pallet_community::Config>::CommunityId,
		Blake2_128Concat,
		<T as pallet::Config>::ProposalId,
		Proposal<
			<T as pallet::Config>::DescriptionLimit,
			<T as pallet::Config>::NameLimit,
			<T as frame_system::Config>::AccountId,
			<T as pallet::Config>::AccountLimit,
		>,
		OptionQuery,
	>;
}
pub mod v1 {
	use frame_support::{pallet_prelude::*, weights::Weight};

	use super::*;

	pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
	impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
		fn on_runtime_upgrade() -> Weight {
			let current_version = Pallet::<T>::current_storage_version();
			let onchain_version = Pallet::<T>::on_chain_storage_version();

			if onchain_version == 0 && current_version == 1 {
				let mut translated = 0u64;
				let proposals = v0::Proposals::<T>::drain().collect::<Vec<_>>();

				for (community_id, _, old_proposal) in proposals {
					translated.saturating_inc();
					let proposal_id = NextProposalId::<T>::get(community_id)
						.unwrap_or(T::ProposalId::initial_value());

					let new_proposal = Proposal {
						proposer: old_proposal.proposer,
						name: old_proposal.name,
						description: old_proposal.description,
						historical: old_proposal.historical,
						status: old_proposal.status,
						voter_accounts: old_proposal.voter_accounts,
					};

					crate::Proposals::<T>::insert(community_id, proposal_id, new_proposal);

					let next_proposal_id = proposal_id.increment();
					crate::NextProposalId::<T>::insert(community_id, next_proposal_id);
				}

				current_version.put::<Pallet<T>>();
				log::info!(
					target: LOG_TARGET,
					"Proposal Upgraded {} pools, storage to version {:?}",
					translated,
					current_version
				);
				T::DbWeight::get().reads_writes(translated + 1, translated + 1)
			} else {
				log::info!(
					target: LOG_TARGET,
					"Proposal Migration did not execute. This probably should be removed"
				);
				T::DbWeight::get().reads(1)
			}
		}

		#[cfg(feature = "try-runtime")]
		fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
			frame_support::ensure!(
				Pallet::<T>::on_chain_storage_version() == 0,
				"must upgrade linearly"
			);
			let prev_count = Passports::<T>::iter().count();
			Ok((prev_count as u32).encode())
		}

		#[cfg(feature = "try-runtime")]
		fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
			let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
				"the state parameter should be something that was generated by pre_upgrade",
			);
			let post_count = Passports::<T>::iter().count() as u32;
			assert_eq!(
				prev_count, post_count,
				"the community count before and after the migration should be the same"
			);

			let current_version = Pallet::<T>::current_storage_version();
			let onchain_version = Pallet::<T>::on_chain_storage_version();

			frame_support::ensure!(current_version == 1, "must_upgrade");
			assert_eq!(
				current_version, onchain_version,
				"after migration, the current_version and onchain_version should be the same"
			);

			Ok(())
		}
	}
}

#[cfg(test)]
#[cfg(feature = "try-runtime")]
mod test {
	use super::*;
	use crate::mock::{Test as T, *};
	use frame_support::pallet_prelude::StorageVersion;

	#[test]
	fn migration_works() {
		new_test_ext().execute_with(|| {
			assert_eq!(StorageVersion::get::<Pallet<T>>(), 0);

			create_community();
			setup_blocks(5);
			create_community();

			assert_eq!(Proposals::<T>::iter_values().count() as u32, 2);

			let state = v1::MigrateToV1::<T>::pre_upgrade().unwrap();
			let _w = v1::MigrateToV1::<T>::on_runtime_upgrade();
			v1::MigrateToV1::<T>::post_upgrade(state).unwrap();

			assert_eq!(Proposals::<T>::iter_values().count() as u32, 2);
			assert_eq!(StorageVersion::get::<Pallet<T>>(), 1);
		});
	}
}
