use super::*;
use frame_support::{log, traits::OnRuntimeUpgrade};
use sp_runtime::Saturating;

pub mod v5 {
    use frame_support::{pallet_prelude::*, weights::Weight};

    use super::*;

    pub struct MigrateToV5<T>(sp_std::marker::PhantomData<T>);
    impl<T: Config> OnRuntimeUpgrade for MigrateToV5<T> {

        fn on_runtime_upgrade() -> Weight {
            let current_version = Pallet::<T>::current_storage_version();
            let onchain_version = Pallet::<T>::on_chain_storage_version();

            if onchain_version == 5 && current_version == 6 {
                let mut translated = 0u64;
                for (id, community) in Communities::<T>::iter() {
                    translated.saturating_inc();
                    <CommunityAccount<T>>::try_mutate(community.founder, |communities| -> DispatchResult {
                        communities
                            .try_push(id)
                            .map_err(|_| Error::<T>::TooManyCommunities)?;
                        Ok(())
                    }).unwrap();
                }
                current_version.put::<Pallet<T>>();
                log::info!(
					target: LOG_TARGET,
					"Upgraded {} pools, storage to version {:?}",
					translated,
					current_version
				);
                T::DbWeight::get().reads_writes(translated + 1, translated + 1)
            } else {
                log::info!(
					target: LOG_TARGET,
					"Migration did not execute. This probably should be removed"
				);
                T::DbWeight::get().reads(1)
            }
        }

        #[cfg(feature = "try-runtime")]
        fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
            frame_support::ensure!(
				Pallet::<T>::on_chain_storage_version() == 1,
				"must upgrade linearly"
			);
            let prev_count = Communities::<T>::iter().count();
            Ok((prev_count as u32).encode())
        }

        #[cfg(feature = "try-runtime")]
        fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
            let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
                "the state parameter should be something that was generated by pre_upgrade",
            );
            let post_count = Communities::<T>::iter().count() as u32;
            assert_eq!(
                prev_count, post_count,
                "the community count before and after the migration should be the same"
            );

            let current_version = Pallet::<T>::current_storage_version();
            let onchain_version = Pallet::<T>::on_chain_storage_version();

            frame_support::ensure!(current_version == 2, "must_upgrade");
            assert_eq!(
                current_version, onchain_version,
                "after migration, the current_version and onchain_version should be the same"
            );

            Ok(())
        }
    }
}


#[cfg(test)]
#[cfg(feature = "try-runtime")]
mod test {
    use frame_support::pallet_prelude::StorageVersion;
    use super::*;
    use crate::mock::{Test as T, *};

    #[test]
    fn migration_works() {
        new_test_ext().execute_with(|| {
            assert_eq!(StorageVersion::get::<Pallet<T>>(), 0);

            create_community();
            setup_blocks(5);
            create_community();

            assert_eq!(Communities::<T>::iter_values().count() as u32, 2);

            let state = v3::MigrateToV3::<T>::pre_upgrade().unwrap();
            let _w = v3::MigrateToV3::<T>::on_runtime_upgrade();
            v3::MigrateToV3::<T>::post_upgrade(state).unwrap();

            assert_eq!(Communities::<T>::iter_values().count() as u32, 2);
            assert_eq!(StorageVersion::get::<Pallet<T>>(), 2);
            assert_ne!(Some(Communities::<Test>::get(1).unwrap().reference_id), Some(Communities::<Test>::get(0).unwrap().reference_id));
        });
    }
}