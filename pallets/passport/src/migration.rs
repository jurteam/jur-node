use super::*;
use frame_support::{log, traits::OnRuntimeUpgrade};
use frame_support::sp_runtime::Saturating;
use sp_std::vec;

pub mod v1 {
    use frame_support::{pallet_prelude::*, weights::Weight};

    use super::*;

    #[derive(Decode)]
    pub struct OldPassportDetails<PassportId, AddressLimit: Get<u32>> {
        pub id: PassportId,
        pub address: Option<BoundedVec<u8, AddressLimit>>,
    }

    pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
    impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {

        fn on_runtime_upgrade() -> Weight {
            let current_version = Pallet::<T>::current_storage_version();
            let onchain_version = Pallet::<T>::on_chain_storage_version();

            if onchain_version == 0 && current_version == 1 {
                let mut translated = 0u64;
                Passports::<T>::translate::<
                    OldPassportDetails<T::PassportId, T::AddressLimit>,
                    _,
                >(|_key, _key2, old_value| {
                    translated.saturating_inc();

                    Some(
                        PassportDetails {
                            id: old_value.id,
                            address: old_value.address,
                            badges: vec![],
                        }
                    )
                });

                current_version.put::<Pallet<T>>();
                log::info!(
					target: LOG_TARGET,
					"Upgraded {} pools, storage to version {:?}",
					translated,
					current_version
				);
                T::DbWeight::get().reads_writes(translated + 1, translated + 1)
            } else {
                log::info!(
					target: LOG_TARGET,
					"Migration did not execute. This probably should be removed"
				);
                T::DbWeight::get().reads(1)
            }
        }

        #[cfg(feature = "try-runtime")]
        fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
            frame_support::ensure!(
				Pallet::<T>::on_chain_storage_version() == 0,
				"must upgrade linearly"
			);
            let prev_count = Passports::<T>::iter().count();
            Ok((prev_count as u32).encode())
        }

        #[cfg(feature = "try-runtime")]
        fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
            let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
                "the state parameter should be something that was generated by pre_upgrade",
            );
            let post_count = Passports::<T>::iter().count() as u32;
            assert_eq!(
                prev_count, post_count,
                "the community count before and after the migration should be the same"
            );

            let current_version = Pallet::<T>::current_storage_version();
            let onchain_version = Pallet::<T>::on_chain_storage_version();

            frame_support::ensure!(current_version == 1, "must_upgrade");
            assert_eq!(
                current_version, onchain_version,
                "after migration, the current_version and onchain_version should be the same"
            );

            Ok(())
        }
    }
}


#[cfg(test)]
#[cfg(feature = "try-runtime")]
mod test {
    use frame_support::pallet_prelude::StorageVersion;
    use super::*;
    use crate::mock::{Test as T, *};

    #[test]
    fn migration_works() {
        new_test_ext().execute_with(|| {
            assert_eq!(StorageVersion::get::<Pallet<T>>(), 0);

            create_community();
            setup_blocks(5);
            create_community();
            mint_passport();

            assert_eq!(Passports::<T>::iter_values().count() as u32, 2);

            let state = v1::MigrateToV1::<T>::pre_upgrade().unwrap();
            let _w = v1::MigrateToV1::<T>::on_runtime_upgrade();
            v1::MigrateToV1::<T>::post_upgrade(state).unwrap();

            assert_eq!(Passports::<T>::iter_values().count() as u32, 2);
            assert_eq!(StorageVersion::get::<Pallet<T>>(), 1);
        });
    }
}